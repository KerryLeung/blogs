---
layout:     post 
title:      å†™Golang UTçš„å‡ ç§æ–¹æ³•          
subtitle:   native way
date:       2018-09-13             
author:     kliang                  
header-img: img/post-bg-2015.jpg    
catalog: true                      
tags:                            
    - golang
    - UT 
---

## æ€ä¹ˆæ ·åœ¨Golangé‡Œé¢å†™UT
UT testæ˜¯æµ‹è¯•ä¸­çš„æœ€å°æµ‹è¯•å•å…ƒï¼Œä¸€èˆ¬è€Œè¨€ï¼Œéœ€è¦fake è¾“å…¥ï¼Œcompareé¢„æœŸè¾“å‡ºï¼Œæœ€ç†æƒ³æˆ–è€…æœ€ç®€å•çš„æƒ…å†µæ˜¯è¾“å…¥ç‰¹åˆ«æ˜“äºfakeï¼Œçœ‹ä¸‹é¢çš„ä¾‹å­
å»ºè®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå®ç°â•1åŠŸèƒ½çš„å‡½æ•° `sum.go`

```
// sum.go
package sum

func addOne(a int) int {
	return a + 1
}
```
å¦‚æœä½ è¦ä¸ºè¿™ä¸ªå‡½æ•°å†™UTï¼Œä½ éœ€è¦åˆ›å»ºä¸€ä¸ªæµ‹è¯•æ–‡ä»¶  `sum_test.go`,è¿™æ ·å½“ä½ è¿è¡Œå‘½ä»¤ `go test xxx`æ—¶, go ä¼šè‡ªåŠ¨è¿è¡Œpackageä¸‹é¢çš„æ‰€æœ‰çš„ `*_test.go` 

```
// sum_test.go
package sum

import (
	"errors"
	"testing"
)

func TestAddOne(t *testing.T) {// function name must bu Upper case, or it will not be run
	if addOne(3) != 4 {
		t.Errorf("the expect result should be 4, but got %v", addOne(3))
		return 
	}
}
```
UTçš„éš¾ç‚¹åœ¨äºinputçš„fakeï¼Œåœ¨çœŸå®é¡¹ç›®ä¸­ï¼Œå¾ˆå°‘æœ‰å‡½æ•°çš„è¾“å…¥ä¼šä¸Šä¸Šä¾‹ä¸­çš„ä¸€æ ·ç®€å•ï¼Œåœ¨å¤§ä¸€ç‚¹çš„é¡¹ç›®ä¸­ï¼Œè‚¯å®šä¼šç”¨åˆ°å‡½æ•°çš„ç»„è£…ï¼Œæµç¨‹æ§åˆ¶ï¼Œå¤–éƒ¨åŒ…ï¼Œç³»ç»Ÿå‡½æ•°çš„å¼•ç”¨ç­‰ç­‰ï¼Œå¯¹äºå¤æ‚è¾“å…¥çš„æƒ…å†µï¼Œæ€ä¹ˆæ ·å†™UTå‘¢ï¼Ÿ
### æµç¨‹æ§åˆ¶å‡½æ•°çš„mock
æˆ‘ä»¬çœ‹ä¸€ä¸ªä¾‹å­

```
// car.go
package car

type Car struct {
}

func NewCar() *Car {
	return &Car{}
}

func (c *Car) start() error {
	return nil
}

func (c *Car) stop() error {
	return nil
}

func run(car *Car) error {
	if err := car.assemble(); err != nil {
		return err
	}

	if err := car.start();  err != nil {
		return err
	}

	if err := car.stop();  err != nil {
		return err
	}
}

func main() {
	car := NewCar()
	run(car)
}

```
åœ¨ä¸Šä¾‹ä¸­, `run` ç»„åˆäº†ä¸‰ä¸ªå‡½æ•°ï¼Œé€šå¸¸UTçš„åšæ³•å°±æ˜¯è®© `run`å‡½æ•°æ¥æ”¶ä¸€ä¸ª interfaceç±»å‹çš„å‚æ•°ï¼Œè€Œä¸æ˜¯ä¸€ç§å…·ä½“çš„å®ç°ç±»å‹ï¼Œè®©æˆ‘ä»¬æŒ‰ç…§è¿™ä¸ªæ€è·¯æ”¹åŠ¨ä¸‹

```
type RunBehavior interface {
	start() error
	stop() error
}

func run(r RunBehavior) {
	if err := r.start();  err != nil {
		return err
	}

	if err := r.stop();  err != nil {
		return err
	}
}

func main() {
	car := NewCar()
	run(car)
}
```

ç»è¿‡æ”¹åŠ¨ä¹‹åï¼Œ `run` çš„è¾“å…¥å‚æ•°æ˜¯ä¸€ä¸ªæ¥å£ `RunBehavior`ï¼Œ ç„¶åæˆ‘ä»¬çœ‹æ€ä¹ˆæ ·å¯¹ `run` è¿›è¡ŒUT

```
// car_test.go
package car

import "fmt"

type testCar {
	startErr error
	stopErr error
}

func (c *Car) start() error {
	return c.startErr
}

func (c *Car) stop() error {
	return c.stopErr
}

func TestRun(t *testing.T) {
	// start error
	car := &testCar{startErr: fmt.Errorf("start error, exit")}
	if err := run(car); err == nil || err.Error() != "start error, exit" {
		t.Errorf("xxx")
		return
	}
	// start error
	car := &testCar{stopErr: fmt.Errorf("stop error, exit")}
	if err := run(car); err == nil || err.Error() != "stop error, exit" {
		t.Errorf("xxx")
		return
	}
	// ok
	car := &testCar{}
	if err := run(car); err != nil {
		t.Errorf("xxx")
		return
	}
}
```
ä»ä¸Šä¾‹å­ä¸­èƒ½çœ‹åˆ°ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª `testCar` çš„å®ç°ï¼Œç„¶åå¯¹ `run` è¿›è¡Œæµ‹è¯•çš„æ—¶å€™ï¼Œå°±å¯ä»¥å¾ˆå®¹æ˜“çš„ run å‡½æ•°ä¸­çš„æ¯ä¸€æ­¥æµç¨‹è¿›è¡Œæ§åˆ¶ï¼Œä½ å¯ä»¥å¾—åˆ°ä»»æ„è¾“æƒ³è¦çš„æ¯ä¸€æ­¥è¿”å›ç»“æœ

### ç³»ç»Ÿè°ƒç”¨çš„mock

```
// read.go
import "os"

func read(path string) error {
	f, err := os.Open("notes.txt")
	if err != nil {
	    return err
	}
	return nil
}
```
å¦‚æœè¦å¯¹ `read ` å‡½æ•°åšæµ‹è¯•ï¼Œå¹¶æ²¡æœ‰å¤ªå¥½çš„åŠæ³•ï¼Œé€šå¸¸æœ‰ä¸¤ç§åšæ³•ï¼Œä¸€ç§æ˜¯ æŠŠ `os.OpenFile ` åšæˆä¸€ä¸ªå‚æ•°
```
var osOpen = os.Open

func read(path string) error {
	f, err := osOpen("notes.txt")
	if err != nil {
	    return err
	}
	return nil
}
```
æµ‹è¯•çš„æ—¶å€™å®šä¹‰è‡ªå·±çš„å‡½æ•°å»æ›¿æ¢ç³»ç»Ÿå‡½æ•°

```
    oldOsOpen := osOpen
    defer func() { osOpen = oldOsOpen }()

    myOpen := func(path string)(*os.File, error) {
        return nil, nil
    }
    osOpen = myOpen
```
è¿™ç§åšæ³•æ˜¯hackçš„åšæ³•ï¼Œæ¯”è¾ƒå‡ºé”™ï¼Œéœ€è¦ç”¨åˆ°å…¨å±€å˜é‡ï¼Œä½†æ˜¯ç¡®å®å¯ä»¥æŠŠä¸€äº›ä¸èƒ½æµ‹åˆ°çš„å‡½æ•°å˜å¾—å¯æµ‹è¯•ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨æ¥å£çš„æ–¹æ³•ï¼Œè®© `read` å‡½æ•°æ¥æ”¶ä¸€ä¸ª `io.Reader` interface, è¿™ç§æ–¹æ³•å°±å¥½å¾—å¤šã€‚
### å‡½æ•°ä½œä¸ºå‚æ•°
è¿˜æœ‰ä¸€ç§æ¯”è¾ƒæ”¹è¿›çš„åšæ³•æ˜¯æŠŠå‡½æ•°ä½œä¸ºå‚æ•°æ”¾åˆ°å‚æ•°é‡Œé¢

```
type OpenFunc func(string) (*File, error)
func read(fn OpenFunc, path string) error {
	f, err := fn(path)
	if err != nil {
	    return err
	}
	return nil
}
```
é€šè¿‡æŠŠå‡½æ•°ä½œä¸ºå‚æ•°ï¼Œä¹Ÿå¯ä»¥å¾ˆå®¹æ˜“çš„mockæ‰å‡½æ•°è°ƒç”¨å‡½æ•°çš„æƒ…å†µï¼Œä½†æ˜¯è¿™ç§åšæ³•é€‚ç”¨äºå‡½æ•°å†…è°ƒç”¨å‡½æ•°çš„æ•°é‡æ¯”è¾ƒå°‘ï¼Œå¦åˆ™ä½ å°±éœ€è¦ä¼ é€’å¤§é‡çš„å‡½æ•°å‚æ•°ä½œä¸ºè¾“å…¥ï¼Œè¿™æ ·ä»£ç å†™å‡ºæ¥ä¹Ÿå¾ˆä¸‘é™‹ã€‚

## å°ç»“
golangåŸç”ŸUTçš„æ–¹æ³•å°±æ˜¯å°½é‡ä½¿ç”¨æ¥å£ä½œä¸ºå‚æ•°ï¼Œå°½é‡ä¸å¼•å…¥æ¯”è¾ƒheavyçš„æµ‹è¯•æ¡†æ¶ï¼Œ ä½†æ˜¯ `sqlmock` æ­¤ç±»æŸ¥è¯¢è°ƒç”¨çš„æ²¡æœ‰å¤ªå¥½çš„åŠæ³•ï¼Œè¿˜æ˜¯ä¹–ä¹–çš„ä½¿ç”¨ç¬¬ä¸‰åŒ…æ¯”è¾ƒçœå¿ƒã€‚golangçš„UTç¡®å®æ²¡æœ‰pythonçš„å¥½å†™ï¼Œpythonæ”¯æŒçš„å„ç§é«˜çº§mockï¼Œå¯ä»¥è®©ä½ ä»»æ„æ›¿æ¢æ‰å‡½æ•°å†…çš„ä»»æ„å‡½æ•°çš„è¿”å›å€¼ï¼Œè™½ç„¶è¿™æ ·æ˜“äºUTï¼Œä½†æ˜¯è¿™ä¹Ÿæ˜¯åŒåˆƒå‰‘ã€‚åƒgolangè¿™æ ·çš„UTç­–ç•¥ï¼Œå¯¹ä»£ç å®ç°çš„ç»„ç»‡å’Œè®¾è®¡è¦æ±‚æ¯”è¾ƒé«˜ï¼Œå¦åˆ™ä»£ç æ ¹æœ¬å°±æ²¡åŠæ³•UTğŸ¤£ã€‚
